 현재 진행중인 프로젝트에 팀원의 코드를 리뷰하면서,
필드에 `@Autowired` 어노태이션을 붙여 의존성 주입하는 것을 발견했습니다.

 올해 초 nhn 세미나에서 생성자 주입을 사용하도록 배웠지만 comment를 작성하는데 이유를 설명하지 못했습니다. (역시 사람은 망각의 동물...)

그래서 이번 기회에 **'왜 생성자 주입을 해야하는가'** 라는 주제로 정리해보겠습니다.

먼저, 의존성 주입 방법 3가지에 대해 먼저 알아봅시다.

# 의존성 주입 방법 3가지



## Field Injection 

~~~ java
@Controller
public class UserController {
  
  @Autowired
  private UserService userService;
}
~~~

세미나에서 배우기 전 사용하던 방식입니다. 의존성을 주입하고자 하는 필드에 `@Autowired` 어노테이션만 추가하면 됩니다.

 가장 간단하고 가독성도 좋아보입니다.



## Setter Injection 

~~~ java
@Controller
public class UserController {
  
  private UserService userService;
  
  @Autowired
  public void setUserService(UserService userService) {
    this.userService = userService;
  }
}
~~~

Setter Injection은 Setter에 `@Autowired` 어노테이션을 추가하는 방법입니다.



## Constructor Injection

~~~ java
@Controller
public class UserController {
  
  private final UserService userService;
  
  public Usercontroller(final UserService userService) {
    this.userService = userService;
  }
}
~~~



위 3가지 방법을 보면 처음엔 누구나 Field Injection을 사용할 것입니다. 하지만 왜 Constructor Injection을 권장하는지 알아봅시다,



# Field Injection의 문제점



## 단일 책임 원칙 위반

Field Injection은 의존성을 추가하기 매우 쉽습니다. 그래서 잘못된 것을 인지하지 못하고 의존성을 마구마구 집어 넣을 수 있습니다. 

하지만, 의존성 주입에 생성자를 사용한다면?

의존성 주입을 위해 생성자의 인자가 추가될 것이고, 생성자의 인자가 너무 많아지면 우리는 설계나 어떤 것이 잘못되었다는 것을 확실히 느낄 수 있을 것입니다.

**많은 의존성을 가진다는 것은  그 클래스에 책임이 많다는 것을 의미합니다.** 이는 단일 책임 원칙, 관심사의 분리를 위반하는 것일 수 있고, 그 클래스에 대한 검사와 리팩토링이 필요하다는 것입니다.

> **쉽게 말해서, Field Injection은 의존성을 추가하기 쉬워서 단일 책임 원칙을 위반하는지 모를 수 있다.
> 단일 책임 원칙 위반 가능성이 높아진다!**











> 참고 자료: https://www.vojtechruzicka.com/field-dependency-injection-considered-harmful/
