# 3장 HTTP 메시지
HTTP가 인터넷의 배달원이라면, HTTP 메시지는 무언가를 담아 보내는 소포와 같다.
이번장에서 공부할 내용

- 메시지가 어떻게 흘러가는가
- HTTP 메시지의 세 부분(시작줄, 헤더, 개체 본문)
- 요청과 응답 메시지의 차이
- 요청 메시지가 지원하는 여러 기능(메서드)들
- 응답 메서드가 반환하는 여러 상태 코드들
- 여러 HTTP 헤더들은 무슨 일을 하는가



## 3.1 메시지의 흐름

**HTTP 메시지는 HTTP 애플리케이션 간에 주고받는 데이터의 블록들**이다. 이 데이터의 블록들은 **메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 그 다음에 선택적으로 데이터가 올 수 있다.** 이 메시지는 클라이언트, 서버, 프락시 사이를 흐른다. '인바운드', '아웃바운드', '업스트림', '다운스트림'은 메시지의 방향을 의미하는 용어다.



### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다

HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다. 메시지가 **원 서버로 향하는 것은 인바운드**로 이동하는 것이고, 모든 처리가 끝난 뒤에 메시지가 **사용자 에이전트로 돌아오는 것은 아웃바운드**로 이동하는 것이다.

![image](https://user-images.githubusercontent.com/22893111/71709716-2f9daf00-2e3c-11ea-8547-6a26d4264674.png)

### 3.1.2 다운스트림으로 흐르는 메시지

HTTP 메시지는 강물과 같이 흐른다. 요청 메시지냐 응답 메시지냐에 관계 없이 모든 메시지는 다운스트림으로 흐른다. 메시지의 발송자는 수신자의 업스트림이다.

![image](https://user-images.githubusercontent.com/22893111/71709845-bfdbf400-2e3c-11ea-9e96-f2852b441153.png)



## 3.2 메시지의 각 부분

HTTP 메시지는 단순한, 데이터의 구조화된 블록이다. 각 메시지는 클라이언트로부터의 요청이나 서버로부터의 응답 중 하나를 포함한다. 메시지는 **시작줄, 헤더 블록, 본문** 이렇게 세 부분으로 이루어진다. 시작줄은 이것이 어떤 메시지인지 서술하며, 헤더 블록은 속성을, 본문은 데이터를 담고 있다. 본문은 아예 없을 수도 있다.

![image](https://user-images.githubusercontent.com/22893111/71710065-be5efb80-2e3d-11ea-9d8c-2fd1630862b1.png)

 시작줄과 헤더는 그냥 줄 단위로 분리된 아스키 문자열이다.

엔티티 본문이나 메시지 본문은 단순히 선택적인 데이터 덩어리이다. 시작줄이나 헤더와는 달리, 본문은 텍스트나 이진 데이터를 포함할 수도 있고 그냥 비어있을 수도 있다.

### 3.2.1 메시지 문법

모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다. 요청 메시지는 웹 서버에 어떤 동작을 요구한다. 응답 메시지는 요청의 결과를 클라이언트에게 돌려준다. 요청과 응답 모두 기본적으로 구조가 같다. 아래 그림은 GIF image를 가져오기 위한 요청과 응답 메시지를 보여준다.

![image](https://user-images.githubusercontent.com/22893111/71710154-362d2600-2e3e-11ea-8f4a-f7620fe8d35e.png)

요청 메시지의 형식은 다음과 같다

~~~ http
<메서드> <요청 URL> <버전>
<헤더>

<엔티티 본문>
~~~

응답 메시지의 형식은 다음과 같다. (시작줄에서만 문법이 다르다)

~~~ http
<버전> <상태 코드> <사유 구절>
<헤더>

<엔티티 본문>
~~~

각 부분에 대해 알아보자.

#### 메서드

클라이언트 측에서 버서가 리소스에 대해 수행해주길 바라는 동작이다. 'GET', 'HEAD', 'POST'와 같이 한 단어로 되어 있다.

#### 요청 URL

요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소다. 완전한 URL이 아닌 URL의 경로 구성요소라고 해도, 클라이언트가 서버와 직접 대화하고 있고 경로 구성요소가 리소스를 가리키는 절대 경로이기만 하면 대체로 문제가 없다. 서버는 URL에서 생략된 호스트/포트가 자신을 가리키는 것으로 간주할 것이다.

#### 버전

이 메시지에서 사용 중인 HTTP의 버전이다. 형식은 다음과 같다.

> HTTP/<메이저>.<마이너>

#### 상태 코드

요청 중에 무엇이 일어났는지 설명하는 세 자리 숫자다. 각 코드의 첫 번째 자릿수는 상태의 일반적인 분류(성공, 에러 등)를 나타낸다.

#### 사유 구절

숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구로, 상태 코드 이후부터 줄바꿈 문자열까지가 사유 구절이다. 사유 구절은 오로지 사람에게 읽히기 위한 목적으로만 존재한다.

#### 헤더들

이름, 콜론(:), 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들. 이 헤더의 목록은 빈 줄(CRLF)로 끝나 헤더 목록의 끝과 엔티티 본문의 시작을 표시한다.

#### 엔티티 본문

엔티티 본문은 임의의 데이터 블록을 포함한다. 모든 메시지가 엔티티 본문을 갖는 것은 아니므로, 때때로 메시지는 그냥 CRLF으로 끝나게 된다.

### 3.2.2 시작줄

모든 HTTP 메시지는 시작줄로 시작한다. 요청 메시지의 시작줄은 무엇을 해야 하는지 말해준다. 응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.

#### 요청줄

요청 메시지는 서버에게 리소스에 대해 무언가를 해달라고 부탁한다. 요청 메시지의 시작줄, 혹은 요청줄에는 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지칭하는 요청 URL이 들어 있다. 또한 요청 줄은 클라이언트가 어떤 HTTP 버전으로 말하고 있는지 서버에게 알려주는 HTTP 버전도 포함한다.

#### 응답줄

응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다. 응답 메시지의 시작줄 혹은 응답줄에는 응답 메시지에서 쓰인 HTTP의 버전, 숫자로 된 상태 코드, 수행 상태에 대해 설명해주는 텍스트로 된 사유 구절이 들어 있다.

#### 메서드

요청의 시잘줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해준다.

| 메서드  | 설명                                                        | 메시지 본문이 있는가? |
| ------- | ----------------------------------------------------------- | --------------------- |
| GET     | 서버에서 어떤 문서를 가져온다                               | X                     |
| HEAD    | 서버에서 어떤 문서에 대해 헤더만 가져온다                   | X                     |
| POST    | 서버가 처리해야 할 데이터를 보낸다                          | O                     |
| PUT     | 서버에 요청 메시지의 본문을 저장한다                        | O                     |
| TRACE   | 메시지가 프록시 서버를 거쳐 서버에 도달하는 과정을 추적한다 | X                     |
| OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다              | X                     |
| DELETE  | 서버에서 문서를 제거한다                                    | X                     |



#### 상태 코드

메서드가 서버에게 무엇을 해야 하는지 말해주는 것처럼, 상태 코드는 클라이언트에게 무엇이 일어났는지 말해준다. 상태 코드는 응답의 시작줄에 위치한다. 예를 들어, `HTTP/1.0 200 OK` 라는 줄에서 상태 코드는 200이다. 

 상태 코드들은 세 자리 숫자로 된 그들의 코드값을 기준으로 묶인다.

| 전체 범위 | 정의된 범위 | 분류            |
| --------- | ----------- | --------------- |
| 100-199   | 100-101     | 정보            |
| 200-299   | 200-206     | 성공            |
| 300-399   | 300-305     | 리다이렉션      |
| 400-499   | 400-415     | 클라이언트 에러 |
| 500-599   | 500-505     | 서버 에러       |

#### 사유 구절

사유 구절은 응답 시작줄의 마지막 구성요소다. 이것은 상태 코드에 대한 글로 된 설명을 제공한다. 사유 구절은, 애플리케이션 개발자들이 그들의 사용자에게 요청 중에 무슨 일이 일어났는지 알려주기 위해 넘겨줄 수 있는, 상태 코드의 사람이 이해하기 쉬운 버전이다.

#### 버전 번호

버전 번호는 HTTP/x.y 형식으로 요청과 응답 메시지 양쪽 모두에 기술된다. 이것은 HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단이 된다.

버전 번호는 어떤 애플리케이션이 지원하는 가장 높은 HTTP 버전을 가리킨다.

### 3.2.3 헤더

시작줄 다음에는 0개~여러 개의 HTTP 헤더가 온다.

HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다. 기본적으로 이름/값 쌍 목록이다.

#### 헤더 분류

- 일반 헤더: 요청과 응답 양쪽에 모두 나타날 수 있음
- 요청 헤더: 요청에 대한 부가 정보를 제공
- 응답 헤더: 응답에 대한 부가 정보를 제공
- Entity 헤더: 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
- 확장 헤더: 명세에 정의되지 않은 새로운 헤더



### 3.2.4 엔티티 본문

HTTP 메시지의 세 번째 부분은 선택적인 엔티티 본문이다. HTTP 메시지는 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션 등 여러 종류의 디지털 데이터를 실어 나를 수 있다.



## 3.3 메서드

#### 3.3.1 안전한 메서드(Safe Method)

HTTP는 안전한 메서드라 불리는 메서드의 집합을 정의한다. GET과 HEAD 메서드는 안전하다고 할 수 있는데, 이는 GET이나 HEAD 메서드를 사용하는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 나타낸다.

#### 3.3.2 GET

GET은 주로 서버에게 리소스를 달라고 요청하기 위해 쓰인다.

![image](https://user-images.githubusercontent.com/22893111/71712879-8d38f800-2e4a-11ea-8998-c96b8d6facd7.png)



#### 3.3.3 HEAD

HEAD 메서드는 정확히 GET처럼 동작하지만, 서버는 응답으로 헤더만을 돌려준다. 엔티티 본문은 결코 반환되지 않는다. 이는 클라이언트가 리소스를 실제로 가져올 필요 없이 헤더만을 조사할 수 있도록 해준다. HEAD를 사용하면

- 리소스를 가져오지 않고도 그에 대해 무엇인가(타입이라거나)를 알아낼 수 있다.
- 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
- 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.

![image](https://user-images.githubusercontent.com/22893111/71712944-e1dc7300-2e4a-11ea-96de-0c0f2f95d8ac.png)



#### 3.3.4 PUT

PUT 메서드는 서버에 문서를 쓴다. PUT 메서드의 의미는, 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것이다.

![image](https://user-images.githubusercontent.com/22893111/71713023-35e75780-2e4b-11ea-8b5c-2c5a76a6351e.png)



#### 3.3.5 POST

POST 메서드는 서버에 입력 데이터를 전송하기 위해 설계되었다. 실제로, HTML 폼을 지원하기 위해 흔히 사용된다. 채워진 폼에 담긴 데이터는 서버로 전송되며, 서버는 이를 모아서 필요로 하는 곳에 보낸다.

![image](https://user-images.githubusercontent.com/22893111/71713071-6dee9a80-2e4b-11ea-843d-e065c3a5c69d.png)



#### 3.3.6 TRACE

클라이언트가 어떤 요청을 할 때, 그 요청은 방화벽, 프록시, 게이트웨이 등의 애플리케이션을 통과할 수 있다. TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.

TRACE 요청은 목적지 서버에서 '루프백(loopback)' 진단을 시작한다. 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 되돌려준다. 클라이언트는 자신과 목적지 서버 사이에 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 자신이 보낸 메시지가 망가졌거나 수정되었는지, 만약 그렇다면 어떻게 변경되었는지 확인할 수 있다.

![image](https://user-images.githubusercontent.com/22893111/71713176-ef462d00-2e4b-11ea-9f52-3a5a6d4e5720.png)



#### 3.3.7 OPTIONS

OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다. 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다.

![image](https://user-images.githubusercontent.com/22893111/71713236-3502f580-2e4c-11ea-8cca-37a92becaf30.png)



#### DELETE

DELETE 메서드는 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.

![image](https://user-images.githubusercontent.com/22893111/71713267-582da500-2e4c-11ea-928a-bf51bcaca7b8.png)

